{"version":3,"sources":["webpack://whatstpl/webpack/universalModuleDefinition","webpack://whatstpl/webpack/bootstrap","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/utils.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/errors.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/index.js","webpack://whatstpl/external \"fs\"","webpack://whatstpl/./src/module.ts","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/parser.js","webpack://whatstpl/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","dirname","path","replace","lastIndexOf","length","substring","Separator","basename","filename","extname","dir","match","normalizePath","parts","split","splice","join","getCwd","IsBrowser","location","protocol","host","pathname","process","cwd","isAbsPath","window","XMLHttpRequest","platform","escape","html","String","baseName","getAbsPath","getObjectValues","obj","res","prop","push","getFunctionBodyOffset","fn","fnStr","toString","indexOf","defArr","slice","inNewLine","column","line","UnclosedTagError","SyntaxError","[object Object]","message","super","__export","require","whatstpl_toolkit_1","Module","children","sourceMap","id","code","locals","contents","cache","_module","_exports","default","_require","props","keys","Function","Params","err","stacks","stack","replaceError","createFunction","Error","sourceMaps","EvalRE","RequireRE","FnCallRE","FnBodyOffset","getImportFilename","lineCode","matches","codeArr","funcName","getFuncName","_codeArr","re","RegExp","parseInt","reverse","pair","source","map","node","errors_1","utils_1","AttrRe","Parser","listeners","outputTags","OutputTags","blockTags","BlockTags","renewRegExp","on","attrs","attributes","tag","target","tags","concat","tagStr","pattern","regexp","event","listener","args","type","closed","trimRight","parseHtml","lineStr","left","end","endIndex","nodes","keepPureSpaces","textNode","trimLeft","emit","parent","LineInfo","getLine","index","attachTextNode","commentNode","parseComment","varNode","endColumn","ending","tagClosed","blockNode","applyAttr","blockClosed","NaN","engine","EngineName","snippetNode","leading","quoted","pos","quote","trim","module_1","fs","CompileOption","encoding","removeComments","timeout","withCredentials","headers","Template","options","currentLine","importedModuleCount","layouts","assign","tpl","compile","compileFile","parse","createModule","render","loadTemplate","Promise","resolve","reject","xhr","open","Array","isArray","setRequestHeader","onload","responseText","onabort","onerror","ontimeout","send","readFile","data","before","after","lineEnding","addSourceMap","attachBlockContents","pushCode","indent","attachImport","attachExport","attackBlock","attachIf","attachElseIf","attachElse","attachSwitch","attachCase","attachDefault","attachFor","attachWhile","attachDoWhile","attachLayout","shouldCompile","await","file","constructor","importModule","from","oldName","newName","block","async","params","export","condition","statement","while"],"mappings":"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","file":"whatstpl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"whatstpl\"] = factory();\n\telse\n\t\troot[\"whatstpl\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\nexports.Separator = exports.IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\nfunction escape(html) {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\nexports.escape = escape;\nfunction dirname(path) {\n    if (path == \"/\")\n        return path;\n    let i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, exports.Separator);\n}\nexports.dirname = dirname;\nfunction basename(filename, extname = \"\") {\n    let dir = dirname(filename), basename = (dir == \"./\" && filename.match(/^\\.[\\/\\\\]/) == null)\n        ? filename : filename.substring(dir.length + 1);\n    if (extname) {\n        let i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n    return basename;\n}\nexports.basename = basename;\nfunction extname(filename) {\n    let baseName = basename(filename), i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\nexports.extname = extname;\nfunction normalizePath(path) {\n    let parts = path.split(/\\/|\\\\/);\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        }\n        else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n    return parts.join(exports.Separator);\n}\nexports.normalizePath = normalizePath;\nfunction getCwd() {\n    if (exports.IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    }\n    else {\n        return process.cwd();\n    }\n}\nexports.getCwd = getCwd;\nfunction isAbsPath(path) {\n    return path[0] == \"/\" || path.match(/^[a-zA-Z0-9]+:[\\/\\\\]/) != null;\n}\nexports.isAbsPath = isAbsPath;\nfunction getAbsPath(filename) {\n    if (!isAbsPath(filename)) {\n        let dir = getCwd(), noSep = dir[dir.length - 1] == \"/\";\n        filename = dir + (noSep ? \"\" : exports.Separator) + filename;\n    }\n    return normalizePath(filename);\n}\nexports.getAbsPath = getAbsPath;\nfunction getObjectValues(obj) {\n    let res = [];\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n    return res;\n}\nexports.getObjectValues = getObjectValues;\nfunction getFunctionBodyOffset(fn) {\n    let fnStr = fn.toString(), i = fnStr.indexOf(\"{\") + 1, defArr = fnStr.slice(0, i).split(\"\\n\"), inNewLine = fnStr[i] == \"\\n\", column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2, line = inNewLine ? defArr.length : defArr.length - 1;\n    return { line, column };\n}\nexports.getFunctionBodyOffset = getFunctionBodyOffset;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass UnclosedTagError extends SyntaxError {\n    constructor(message, filename, line, column) {\n        super(message);\n        this.filename = filename;\n        this.line = line;\n        this.column = column;\n    }\n}\nexports.UnclosedTagError = UnclosedTagError;\n//# sourceMappingURL=errors.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./errors\"));\n__export(require(\"./parser\"));\n__export(require(\"./utils\"));\n//# sourceMappingURL=index.js.map","module.exports = require(\"fs\");","import {\n    normalizePath,\n    dirname,\n    isAbsPath,\n    escape,\n    getObjectValues,\n    getFunctionBodyOffset,\n    Node\n} from \"whatstpl-toolkit\";\n\nexport interface SourceMap {\n    [line: string]: {\n        column: number;\n        node: Node;\n    }\n}\n\nexport class Module {\n    id: string;\n    filename: string;\n    dirname: string;\n    code: string;\n    parent: Module;\n    children: { [filename: string]: Module } = {};\n    sourceMap: SourceMap = {};\n\n    static cache: { [filename: string]: Module } = {};\n    static sourceMaps: { [filename: string]: SourceMap } = {};\n\n    constructor(filename: string) {\n        this.id = this.filename = normalizePath(filename);\n        this.dirname = dirname(filename);\n        this.code = \"\";\n    }\n\n    /**\n     * \n     * @param id Module id, usually it's the module filename.\n     * @param locals Local variables passed to the module.\n     * @param contents Layout contents, used when the current module is a \n     *  layout module.\n     */\n    require(id: string, locals: { [name: string]: any } = {}, contents = \"\"): {\n        [name: string]: any;\n        default?: string;\n    } {\n        let filename = isAbsPath(id) || this.dirname == \".\"\n            ? id\n            : normalizePath(this.dirname + \"/\" + id);\n        let dir = dirname(filename);\n\n        if (Module.cache[filename]) {\n            let _module = Module.cache[filename],\n                _exports = { default: \"\" },\n                _require = (id: string, locals = {}, contents = \"\") => {\n                    return _module.require(id, locals, contents);\n                };\n\n            this.children[filename] = _module;\n\n            let fn = createFunction(this.filename, _module.code, locals);\n\n            fn.call(\n                _exports,\n                _require,\n                filename,\n                dir,\n                contents,\n                locals,\n                escape,\n                ...getObjectValues(locals)\n            );\n\n            return _exports;\n        } else {\n            throw new Error(\"the request module hasn't been imported!\");\n        }\n    }\n}\n\nconst Params = \"require, __filename, __dirname, __contents, __locals, __escape\";\nconst EvalRE = /at ([a-zA-Z0-9_\\.]+) \\(eval at.+<anonymous>:(\\d+:\\d+)\\)/;\nconst RequireRE = /const __module_\\d+ = require\\('(.+?)'/;\nconst FnCallRE = /([a-zA-Z0-9_]+).call\\(this.*\\)/;\n\n// The `new Function()` will generate a function which it's string \n// representation is different in different JavaScript engines, so here I \n// calculate out the function body offset from a test function, so that when \n// replacing the error, the program can calculate the accurate position of the\n// function body.\nconst FnBodyOffset = getFunctionBodyOffset(new Function(\"a, b\", \"a + b\"));\n\nfunction createFunction(filename: string, code: string, locals: {\n    [prop: string]: any\n}) {\n    let props = Object.keys(locals).join(\", \");\n\n    try {\n        return new Function(Params + (props ? \", \" + props : \"\"), code);\n    } catch (err) {\n        if (err instanceof SyntaxError) { // replace the error stack.\n            err.message = \"Unexpected token found\";\n            \n            let stacks = err.stack.split(\"\\n\");\n\n            stacks[1] = stacks[1].replace(\"<anonymous>\", filename);\n            err.stack = stacks.join(\"\\n\");\n            \n            throw err;\n        } else {\n            throw replaceError(err, filename);\n        }\n    }\n}\n\n/** Gets the function name from a line of code. */\nfunction getFuncName(lineCode: string): string {\n    let matches = lineCode.match(FnCallRE);\n    return matches ? matches[1] : \"\";\n}\n\n/** Gets the imported filename from a `require()` statement. */\nfunction getImportFilename(code: string, line: number): string {\n    let codeArr = code.split(\"\\n\"),\n        funcName = getFuncName(codeArr[line - 1]),\n        lineCode: string, matches: RegExpMatchArray;\n\n    if (funcName) {\n        let re = new RegExp(`const ${funcName} = (__module_\\\\d+)\\.`),\n            _codeArr: string[], moduleId: string;\n\n        for (let i in codeArr) {\n            matches = codeArr[i].match(re);\n\n            if (matches) {\n                _codeArr = codeArr.slice(0, parseInt(i));\n                moduleId = matches[1];\n\n                break;\n            }\n        }\n\n        if (moduleId && _codeArr && _codeArr.length) {\n            _codeArr.reverse();\n            let re = new RegExp(`const ${moduleId} = require\\\\('(.+?)'`);\n\n            for (let code of _codeArr) {\n                matches = code.match(re);\n\n                if (matches)\n                    return matches[1].replace(/\\\\\\\\/g, \"\\\\\");\n            }\n        } else {\n            return \"\";\n        }\n    } else {\n        // line number starts from 1, while array index starts from 0, so here \n        // must decrease 1.\n        lineCode = codeArr[line - 1];\n        matches = lineCode && lineCode.match(RequireRE);\n\n        return matches ? matches[1].replace(/\\\\\\\\/g, \"\\\\\") : \"\";\n    }\n}\n\n/**\n * Replaces error stack according to the source map.\n * @param filename The main module filename.\n */\nexport function replaceError(err: Error, filename: string): Error {\n    let stacks = err.stack.split(\"\\n\").reverse();\n\n    for (let i in stacks) {\n        // first line the the stack or failed to parse the filename.\n        if (stacks[i][0] != \" \" || !filename) continue;\n\n        let matches = stacks[i].match(EvalRE);\n\n        if (matches) {\n            let funcName = matches[1],\n                pair = matches[2].split(\":\"),\n                line: number = parseInt(pair[0]),\n                column: number = parseInt(pair[1]),\n                // The running code will be wrapped in a function which the \n                // definition takes at least one line, so here the line number \n                // should decrease according to the function body offset.\n                source = {\n                    funcName,\n                    filename,\n                    line: line - FnBodyOffset.line,\n                    column\n                },\n                /** The source map of one line of code. */\n                map = Module.sourceMaps[filename][source.line],\n                code = Module.cache[filename].code;\n\n            // If the source line is 1 (the first line), then the column \n            // should be calculated as well.\n            if (source.line == 1)\n                source.column = column - FnBodyOffset.column;\n\n            // recalculate the filename, move to the next import file.\n            filename = getImportFilename(code, source.line);\n\n            // Replace the line number to the line number in the source file.\n            source.line = map.node.line;\n            // Calculate and replace the column number.\n            source.column = (column - map.column) + map.node.column;\n\n            stacks[i] = `    at ${source.funcName} (${source.filename}`\n                + `:${source.line}:${source.column})`;\n        }\n    }\n\n    // Regenerate the error stack.\n    stacks.reverse();\n    err.stack = stacks.join(\"\\n\");\n\n    return err;\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nconst AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\nclass Parser {\n    constructor(filename = \"\") {\n        this.listeners = {};\n        this.outputTags = Parser.OutputTags;\n        this.blockTags = Parser.BlockTags;\n        if (filename)\n            this.filename = utils_1.getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n        this.renewRegExp();\n        this.on(\"block\", (node) => {\n            let attrs = node.attributes;\n            if (node.tag == \"block\") {\n                this.blockTags.push(attrs.name.value);\n                this.renewRegExp();\n            }\n            else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                let tags = attrs.target.value.split(/,\\s*/);\n                for (let i in tags) {\n                    let pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n                this.blockTags = this.blockTags.concat(tags);\n                this.renewRegExp();\n            }\n        });\n    }\n    renewRegExp() {\n        let tagStr = this.blockTags.join(\"|\");\n        let pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n        this.regexp = new RegExp(pattern);\n    }\n    on(event, listener) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n        this.listeners[event].push(listener);\n    }\n    emit(event, ...args) {\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n        for (let listener of this.listeners[event]) {\n            listener(...args);\n        }\n        return true;\n    }\n    parse(html) {\n        let root = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    }\n    getLine(html, line) {\n        let lineStr, left;\n        while (true) {\n            let end = html.indexOf(\"\\n\");\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n            if (lineStr || !left) {\n                break;\n            }\n            else {\n                line += 1;\n                html = left;\n            }\n        }\n        return { lineStr, left, line };\n    }\n    attachTextNode(lineStr, line, column, endIndex, nodes, keepPureSpaces = false) {\n        let textNode = {\n            type: \"text\",\n            line,\n            column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n        if (keepPureSpaces || textNode.contents.trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode);\n        }\n    }\n    parseHtml(html, line, column = 1, parent) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr.match(this.regexp), nodes = parent.contents;\n        html = LineInfo.left;\n        line = LineInfo.line;\n        if (!matches) {\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                let snippetNode = {\n                    type: \"snippet\",\n                    line,\n                    column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode);\n            }\n            else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        }\n        else if (matches[1] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let left = lineStr.substring(matches.index + matches[0].length), commentNode = {\n                type: \"comment\",\n                line,\n                column,\n                contents: matches[0],\n                closed: false\n            };\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            }\n            else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[2] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let commentNode = {\n                type: \"comment\",\n                line,\n                column,\n                contents: lineStr.substring(matches.index),\n                closed: false\n            };\n            line += 1;\n            column = 1;\n            let res = this.parseComment(html, line, column, commentNode);\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[3] && matches[4]) {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes, matches[3] != \"!\");\n                column += matches.index;\n            }\n            column += 2;\n            let varNode = {\n                tag: matches[3],\n                type: \"var\",\n                line,\n                column,\n                contents: matches[4],\n                closed: true,\n            };\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n            let endColumn = matches.index + matches[4].length + 3, left = lineStr.substring(endColumn);\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[5] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let endColumn = matches.index + matches[0].length, ending = lineStr[endColumn - 1], tagClosed = ending == \"/\" || ending == \">\", blockNode = {\n                tag: matches[5],\n                type: \"block\",\n                line,\n                column,\n                attributes: {},\n                contents: [],\n                closed: false,\n            };\n            if (tagClosed)\n                endColumn -= 1;\n            let left = lineStr.substring(endColumn);\n            if (!left && html) {\n                column = 1;\n                let LineInfo = this.getLine(html, line);\n                if (LineInfo.lineStr) {\n                    left = LineInfo.lineStr;\n                    html = LineInfo.left;\n                }\n            }\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n                if (tagClosed)\n                    column -= 1;\n            }\n            else {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            let res = this.applyAttr(html, line, column, blockNode.attributes);\n            blockNode.closed = res.blockClosed;\n            if (res.left && !blockNode.closed) {\n                res = this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[6] && matches[6] == parent.tag) {\n            if (matches.index && parent.tag != \"script\") {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n            parent.closed = true;\n            let endColumn = matches.index + matches[0].length, left = lineStr.substring(endColumn);\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else {\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n        if (html && !parent.closed) {\n            return this.parseHtml(html, line, column, parent);\n        }\n        else {\n            parent.closed = true;\n            return { line, column, left: html };\n        }\n    }\n    applyAttr(html, line, column, attrs) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, leading = lineStr.trimLeft()[0], tagClosed = leading == \"/\" || leading == \">\", matches = tagClosed ? null : lineStr.match(AttrRe);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (!matches) {\n            let i = lineStr.indexOf(\">\");\n            if (i === -1) {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            else {\n                column += i + 1;\n                let left = lineStr.substring(i + 1);\n                if (left) {\n                    html = left + \"\\n\" + html;\n                }\n                else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n            return {\n                line,\n                column,\n                left: html,\n                blockClosed: leading == \"/\"\n            };\n        }\n        let name;\n        let value;\n        let quoted = true;\n        let left;\n        if (matches[1]) {\n            let pos = matches.index + matches[0].length, quote = lineStr[pos], end;\n            quoted = quote == \"'\" || quote == '\"';\n            if (quoted)\n                pos += 1;\n            if (quoted) {\n                end = lineStr.indexOf(quote, pos);\n            }\n            else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n            name = matches[1],\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        }\n        else if (matches[2]) {\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n        attrs[name] = { name, value, line, column };\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length);\n            column += (quoted ? 1 : 0);\n        }\n        else {\n            line += 1;\n            column = 1;\n        }\n        return this.applyAttr(html, line, column, attrs);\n    }\n    parseComment(html, line, column, commentNode) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr && lineStr.match(/-->/);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n        if (!matches) {\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            }\n            else {\n                return { line, column, left: html };\n            }\n        }\n        else {\n            if (matches.index) {\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n            commentNode.contents += matches[0];\n            commentNode.closed = true;\n            column += matches.index + 3;\n            let left = lineStr.substring(column);\n            if (left) {\n                html = left + \"\\n\" + html;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        return { line, column, left: html };\n    }\n}\nParser.EngineName = \"whatstpl\";\nParser.BlockTags = [\n    \"layout\",\n    \"import\",\n    \"export\",\n    \"block\",\n    \"if\",\n    \"else-if\",\n    \"else\",\n    \"switch\",\n    \"case\",\n    \"default\",\n    \"for\",\n    \"while\",\n    \"do\",\n    \"continue\",\n    \"break\",\n    \"script\",\n];\nParser.OutputTags = [\n    \"!\",\n    \"@\",\n    \"#\",\n];\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map","import {\n    Node,\n    Parser,\n    escape,\n    isAbsPath,\n    extname,\n    dirname,\n    normalizePath,\n    getAbsPath,\n    getCwd,\n    Separator,\n    IsBrowser\n} from \"whatstpl-toolkit\";\nimport { Module, replaceError } from \"./module\";\n\nvar fs: {\n    readFile(filename: string, encoding: string, cb: (err: Error, data: string) => void);\n} = null;\n\nif (!IsBrowser) {\n    fs = require(\"fs\");\n}\n\nexport type Variables = { [name: string]: any };\nexport type Renderer = (locals?: Variables) => string;\n\nexport interface CompileOption {\n    /** For fs.readFile() to decode the file contents. */\n    encoding?: string;\n    /** Whether the compiled function should be cached in memory. */\n    cache?: boolean;\n    /** Whether or not to remove the comments when render HTML. */\n    removeComments?: boolean;\n    /**\n     * Request timeout, used when the program is run in a browser and load \n     * remote template via Ajax.\n     */\n    timeout?: number;\n    /**\n     * Whether or not to send credentials (e.g. cookies) when request, used \n     * when the program is run in a browser and load remote template via Ajax.\n     */\n    withCredentials?: boolean;\n    /**\n     * Request headers, used when the program is run in a browser and load \n     * remote template via Ajax.\n     */\n    headers?: { [name: string]: string | number | boolean | string[] };\n}\n\nexport const CompileOption: CompileOption = {\n    encoding: \"utf8\",\n    cache: false,\n    removeComments: false,\n    timeout: 5000,\n    withCredentials: false,\n    headers: null\n}\n\nexport class Template {\n    filename: string;\n    options: CompileOption;\n    module: Module;\n\n    private currentLine: number = 0;\n    private importedModuleCount: number = 0;\n    private layouts: Array<{ filename: string, node: Node }> = [];\n\n    static cache: { [filename: string]: Renderer } = {};\n\n    constructor(filename?: string, encoding?: string);\n    constructor(filename?: string, options?: CompileOption);\n    constructor(filename = \"\", options: any = \"utf8\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        if (typeof options == \"string\")\n            options = { encoding: options };\n\n        this.options = Object.assign({}, CompileOption, options);\n    }\n\n    /** Renders the given template contents. */\n    async render(tpl: string, locals: Variables = {}): Promise<string> {\n        let render = await this.compile(tpl);\n        return render(locals);\n    }\n\n    /** Renders the given file. */\n    static async renderFile(filename?: string, locals?: Variables, encoding?: string): Promise<string>;\n    static async renderFile(filename?: string, locals?: Variables, options?: CompileOption): Promise<string>;\n    static async renderFile(filename: string, locals: Variables = null, options = null): Promise<string> {\n        let render = await this.compileFile(filename, options);\n        return render(locals || {});\n    }\n\n    /** Compiles the given template contents. */\n    async compile(tpl: string): Promise<Renderer> {\n        // If the function is already cached, retrieve it instead.\n        if (this.options.cache && Template.cache[this.filename]) {\n            return Template.cache[this.filename];\n        }\n\n        let parser = new Parser(this.filename),\n            node: Node = parser.parse(tpl),\n            _module: Module = await this.createModule(node);\n\n        // Wrap the function in a render function, so when it is  called, the \n        // program can catch and re-throw any errors, and only  return the \n        // `default` property (HTML) from the module.\n        let render: Renderer = (locals = {}) => {\n            try {\n                return _module.require(this.filename, locals).default.trimRight();\n            } catch (err) { // replace and re-throw the error.\n                throw replaceError(err, this.filename);\n            }\n        };\n\n        if (this.options.cache)\n            Template.cache[this.filename] = render;\n\n        return render;\n    }\n\n    /** Compiles the given file. */\n    static async compileFile(filename: string, encoding?: string): Promise<Renderer>;\n    static async compileFile(filename: string, options?: CompileOption): Promise<Renderer>;\n    static async compileFile(filename: string, options: any = null): Promise<Renderer> {\n        filename = getAbsPath(filename);\n\n        // If the function is already cached, retrieve it instead.\n        if (options && options.cache && Template.cache[filename]) {\n            return Template.cache[filename];\n        }\n\n        let tpl: Template = new this(filename, options),\n            html = await tpl.loadTemplate();\n\n        return tpl.compile(html);\n    }\n\n    /**\n     * Registers the given template string as a template, and set a temporary\n     * filename for importing usage.\n     */\n    static register(filename: string, tpl: string): Promise<Renderer> {\n        let tplObj = new this(filename, {\n            cache: true\n        });\n\n        return tplObj.compile(tpl);\n    }\n\n    /** Loads the template contents from the file. */\n    protected loadTemplate(): Promise<string> {\n        if (!IsBrowser) {\n            return new Promise((resolve, reject) => {\n                fs.readFile(this.filename, this.options.encoding, (err, data) => {\n                    err ? reject(err) : resolve(data);\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                let xhr = new XMLHttpRequest();\n                xhr.timeout = this.options.timeout;\n                xhr.withCredentials = this.options.withCredentials;\n                xhr.open(\"GET\", this.filename, true);\n\n                if (this.options.headers) {\n                    for (let name in this.options.headers) {\n                        let value: any = this.options.headers[name];\n\n                        if (Array.isArray(value)) {\n                            value = value.join(\", \");\n                        } else if (typeof value != \"string\") {\n                            if (typeof value.toString == \"function\")\n                                value = value.toString();\n                            else\n                                value = String(value);\n                        }\n\n                        xhr.setRequestHeader(name, value);\n                    }\n                }\n\n                xhr.onload = () => {\n                    resolve(xhr.responseText);\n                };\n\n                xhr.onabort = xhr.onerror = xhr.ontimeout = () => {\n                    reject(new Error(\"failed to load remote module.\"));\n                };\n\n                xhr.send();\n            });\n        }\n    }\n\n    /** Gets the absolute path of the filename, if it is relative.  */\n    protected getAbsPath(filename: string): string {\n        if (!isAbsPath(filename)) {\n            let dir = this.filename && this.filename != \"undefined\"\n                ? dirname(this.filename)\n                : getCwd();\n\n            filename = normalizePath(dir + Separator + filename);\n        }\n\n        // If the extension name is omitted, use the one of the parent file.\n        if (!extname(filename)) {\n            filename += extname(this.filename);\n        }\n\n        return filename;\n    }\n\n    /** Adds a line of source map to the internal `sourceMap` property.  */\n    private addSourceMap(column: number, node: Node) {\n        this.currentLine += 1;\n        this.module.sourceMap[this.currentLine] = { column, node };\n    }\n\n    /** Pushes a line of code to the internal `code` object. */\n    protected pushCode(before: string, contents: string, after: string, node: Node, lineEnding = true) {\n        this.module.code += before + contents + after + (lineEnding ? \"\\n\" : \"\");\n        // `length` of a string starts from 0, but column number starts from 1,\n        // so here it should add 1. \n        this.addSourceMap(before.length + 1, node);\n    }\n\n    /** Imports a module from the given file. */\n    protected async importModule(parent: Module = null): Promise<Module> {\n        if (Module.cache[this.filename]) {\n            return Module.cache[this.filename];\n        }\n\n        let tpl = await this.loadTemplate(),\n            parser = new Parser(this.filename),\n            node = parser.parse(tpl);\n\n        return this.createModule(node, parent);\n    }\n\n    /** Creates a new module according to the given filename and node tree. */\n    private async createModule(node: Node, parent: Module = null): Promise<Module> {\n        let _module = new Module(this.filename);\n\n        this.module = _module;\n\n        await this.attachBlockContents(node);\n\n        // If there is any layouts, push then to the very bottom of the \n        // compiled code, and in the layout module, use variable `__contents` \n        // to  attach the inner contents.\n        if (this.layouts.length) {\n            for (let { filename, node } of this.layouts) {\n                this.importedModuleCount += 1;\n\n                let moduleId = \"__module_\" + this.importedModuleCount;\n                filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n\n                // When dealing with layout, only import the `default` property,\n                // and reassign the `default` in the current module.\n                this.pushCode(\n                    `const ${moduleId} = `,\n                    `require('${filename}', __locals, this.default)`,\n                    \";\",\n                    node\n                );\n                this.pushCode(\"this.default = \", `${moduleId}.default`, \";\", node);\n            }\n        }\n\n        _module.parent = parent;\n        Module.cache[this.filename] = _module; // cache the module.\n        Module.sourceMaps[this.filename] = _module.sourceMap; // cache the source map.\n\n        return _module;\n    }\n\n    /** Attaches block contents to the internal `code` object. */\n    private async attachBlockContents(parent: Node, indent = \"\") {\n        let cutSpace = NaN;\n\n        for (let node of <Node[]>parent.contents) {\n            if (node.type == \"text\"\n                || (node.type == \"comment\" && !this.options.removeComments)) {\n                let contents = (<string>node.contents).replace(/\\n/g, \"\\\\n\")\n                    .replace(/'/g, \"\\\\'\");\n\n                this.pushCode(\n                    indent + \"this.default += '\",\n                    contents,\n                    \"';\",\n                    node\n                );\n            } else if (node.type == \"var\") {\n                if (node.tag == \"!\") { // !{statement}\n                    this.pushCode(indent, <string>node.contents, \";\", node);\n                } else if (node.tag == \"@\") { // @{statement}\n                    this.pushCode(\n                        indent + \"this.default += \",\n                        <string>node.contents,\n                        \";\",\n                        node\n                    );\n                } else { // #{statement}\n                    this.pushCode(\n                        indent + \"this.default += __escape(\",\n                        <string>node.contents,\n                        \");\",\n                        node\n                    );\n                }\n            } else if (node.type == \"snippet\") { // <script engine=\"whatstpl\"></script>\n                // if (isNaN(cutSpace)) {\n                //     let match = (<string>node.contents).match(/\\S/);\n\n                //     if (match)\n                //         cutSpace = match.index;\n                // }\n\n                let contents: string = cutSpace\n                    ? (<string>node.contents).substring(cutSpace)\n                    : <string>node.contents;\n\n                this.pushCode(indent.substring(4), contents, \"\", node, false);\n            } else if (node.type == \"block\") {\n                if (node.tag == \"import\") { // <import/>\n                    await this.attachImport(node, indent);\n                } else if (node.tag == \"export\") { // <export/>\n                    await this.attachExport(node, indent);\n                } else if (node.tag == \"block\") { // <block></block>\n                    await this.attackBlock(node, indent);\n                } else if (node.tag == \"if\") { // <if></if>\n                    await this.attachIf(node, indent);\n                } else if (node.tag == \"else-if\") { // <else-if></else-if>\n                    await this.attachElseIf(node, indent.substring(4));\n                } else if (node.tag == \"else\") { // <else></else>\n                    await this.attachElse(node, indent.substring(4));\n                } else if (node.tag == \"switch\") { // <switch></switch>\n                    await this.attachSwitch(node, indent);\n                } else if (node.tag == \"case\") { // <case></case>\n                    await this.attachCase(node, indent);\n                } else if (node.tag == \"default\") { // <default></default>\n                    await this.attachDefault(node, indent);\n                } else if (node.tag == \"for\") { // <for></for>\n                    await this.attachFor(node, indent);\n                } else if (node.tag == \"while\") { // <while></while>\n                    await this.attachWhile(node, indent);\n                } else if (node.tag == \"do\") { // <do></do>\n                    await this.attachDoWhile(node, indent);\n                } else if (node.tag == \"continue\" || node.tag == \"break\") {\n                    // <continue/> and <break/>\n                    this.pushCode(indent, node.tag, \";\", node);\n                } else if (node.tag == \"layout\") { // <layout></layout>\n                    await this.attachLayout(node, indent);\n                } else if (node.tag == \"script\") { // <script></script>\n                    let attrs = node.attributes;\n                    let shouldCompile = !attrs.engine\n                        || attrs.engine.value != Parser.EngineName;\n\n                    if (shouldCompile) { // JavaScript of the HTML.\n                        let contents = \"<script\";\n\n                        // attach attributes.\n                        for (let name in attrs) {\n                            contents += ` ${name}=\"${attrs[name].value}\"`;\n                        }\n\n                        contents += \">\\\\n\";\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            contents,\n                            \"';\",\n                            node\n                        );\n                    }\n\n                    // Attaches the contents in the <script> element.\n                    await this.attachBlockContents(node, indent + \"    \");\n\n                    if (shouldCompile) {\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            \"</script>\\\\n\",\n                            \"';\",\n                            node\n                        );\n                    }\n                } else { // user-defined block tags.\n                    let name = node.tag.replace(/-/g, \"_\"),\n                        attrs = node.attributes;\n\n                    if (attrs.await && attrs.await.value != \"false\")\n                        name = \"await \" + name;\n\n                    let contents = \"call(this\";\n\n                    // User-defined block tags are treated as function, when \n                    // called, the attribute `data` will be used as arguments\n                    // and passed to the function.\n                    if (attrs.data && attrs.data.value)\n                        contents += \", \" + attrs.data.value;\n\n                    contents += \")\";\n\n                    this.pushCode(indent + name + \".\", contents, \";\", node);\n                }\n            }\n        }\n    }\n\n    /** <layout file=\"<filename>\"/> */\n    private async attachLayout(node: Node, indent = \"\") {\n        let filename = this.getAbsPath(node.attributes.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        // The layouts are not attached immediately, they will be stored in \n        // an array, when the current module is compiled, layouts will be \n        // added to the very end of the compiled code.\n        this.layouts.push({ filename, node });\n    }\n\n    /** <import[ target=\"<block-name>\"] file|from=\"<filename>\"/> */\n    private async attachImport(node: Node, indent = \"\") {\n        let attrs = node.attributes,\n            filename = this.getAbsPath(attrs.from ? attrs.from.value : attrs.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        this.importedModuleCount += 1;\n\n        let moduleId = \"__module_\" + this.importedModuleCount;\n        filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n        this.pushCode(\n            `${indent}const ${moduleId} = `,\n            `require('${filename}', __locals)`,\n            \";\",\n            node\n        );\n\n        // The 'target' attribute in a <import/> elements sets which names \n        // should be imported.\n        if (attrs.target && attrs.target.value) {\n            let tags = attrs.target.value.replace(/-/g, \"_\").split(/\\s*,\\s*/);\n\n            for (let tag of tags) {\n                // parse as syntax.\n                let pair = tag.split(/\\s*as\\s*/),\n                    oldName = pair[0],\n                    newName = pair[1] || oldName;\n\n                this.pushCode(\n                    indent,\n                    `const ${newName} = ${moduleId}.${oldName}`,\n                    \";\",\n                    node\n                );\n            }\n        } else { // If no 'target', then import the `default` property.\n            this.pushCode(indent, `this.default += ${moduleId}.default`, \";\", node);\n        }\n    }\n\n    /** <export target=\"<block-names>\"/> */\n    private async attachExport(node: Node, indent = \"\") {\n        // The 'target' attribute in a <export/> elements sets which names \n        // should be exported and can be imported by other modules.\n        if (node.attributes.target && node.attributes.target.value) {\n            let tags = node.attributes.target.value.split(/,\\s*/);\n\n            for (let i in tags) {\n                // parse `as` syntax\n                let pair = tags[i].split(/\\s+as\\s+/),\n                    oldName = pair[0].replace(/-/g, \"_\"),\n                    newName = pair[1] ? pair[1].replace(/-/g, \"_\") : oldName;\n\n                this.pushCode(indent, `this.${newName} = ${oldName}`, \";\", node);\n            }\n        }\n    }\n\n    /** <block name=\"<name>\"[ export][ async][ params=\"<params>\"]></block> */\n    private async attackBlock(block: Node, indent = \"\") {\n        let attrs = block.attributes,\n            name = attrs.name.value.replace(/-/g, \"_\"),\n            contents = `function ${name}(`;\n\n        // 'async' attribute means the function is an async function.\n        if (attrs.async && attrs.async.value != \"false\")\n            contents = `async ` + contents;\n\n        // 'params' attribute sets function parameters.\n        if (attrs.params && attrs.params.value)\n            contents += attrs.params.value;\n\n        contents += \")\";\n\n        this.pushCode(indent, contents, \" {\", block);\n\n        await this.attachBlockContents(block, indent + \"    \");\n\n        this.pushCode(indent, \"\", \"}\", block);\n\n        // The block can be exported by setting an 'export' attribute.\n        if (attrs.export && attrs.export.value != \"false\")\n            this.pushCode(indent, `this.${name} = ${name}`, \";\", block);\n    }\n\n    /** <if condition=\"<condition>\"></if> */\n    private async attachIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <else-if condition=\"<condition>\"></else-if> */\n    private async attachElseIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <else></else> */\n    private async attachElse(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else {\", \"\", \"\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <switch target=\"<target>\"></switch> */\n    private async attachSwitch(block: Node, indent = \"\") {\n        this.pushCode(indent + \"switch (\", block.attributes.target.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <case data=\"<data>\"></case> */\n    private async attachCase(block: Node, indent = \"\") {\n        this.pushCode(indent + \"case \", block.attributes.data.value, \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <default></default> */\n    private async attachDefault(block: Node, indent = \"\") {\n        this.pushCode(indent + \"default\", \"\", \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <for statement=\"<statement>\"></for> */\n    private async attachFor(block: Node, indent = \"\") {\n        this.pushCode(indent + \"for (\", block.attributes.statement.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <while condition=\"<condition>\"></while> */\n    private async attachWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"while (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <do while=\"<condition>\"></do> */\n    private async attachDoWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"do \", \"\", \" {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"} while (\", block.attributes.while.value, \");\", block);\n    }\n}\n\nexport default Template;"],"sourceRoot":""}